--- a/gfx/gl/Colorspaces.h
+++ b/gfx/gl/Colorspaces.h
@@ -84,7 +84,7 @@
     return PiecewiseGammaDesc{
         .a = 1.099,
         .b = 0.018,
-        .g = 1.0 / 0.45,  // ~2.222
+        .g = 1.0f / 0.45f,  // ~2.222
         .k = 4.5,
     };
   }
@@ -93,7 +93,7 @@
     return PiecewiseGammaDesc{
         .a = 1.0993,
         .b = 0.0181,
-        .g = 1.0 / 0.45,  // ~2.222
+        .g = 1.0f / 0.45f,  // ~2.222
         .k = 4.5,
     };
   }
@@ -114,9 +114,9 @@
   static constexpr auto Full8() {  // AKA pc
     return YcbcrDesc{
         .y0 = 0 / 255.0,
-        .y1 = 255 / 255.0,
-        .u0 = 128 / 255.0,
-        .uPlusHalf = 254 / 255.0,
+        .y1 = 255 / 255.0f,
+        .u0 = 128 / 255.0f,
+        .uPlusHalf = 254 / 255.0f,
     };
   }
   static constexpr auto Float() {  // Best for a LUT
--- a/third_party/jpeg-xl/lib/jxl/cms/jxl_cms_internal.h
+++ b/third_party/jpeg-xl/lib/jxl/cms/jxl_cms_internal.h
@@ -1046,12 +1046,12 @@
           break;
         case JXL_TRANSFER_FUNCTION_SRGB:
           JXL_RETURN_IF_ERROR(CreateICCCurvParaTag(
-              {2.4, 1.0 / 1.055, 0.055 / 1.055, 1.0 / 12.92, 0.04045}, 3,
+              {2.4, 1.0f / 1.055f, 0.055f / 1.055f, 1.0f / 12.92f, 0.04045}, 3,
               &tags));
           break;
         case JXL_TRANSFER_FUNCTION_709:
           JXL_RETURN_IF_ERROR(CreateICCCurvParaTag(
-              {1.0 / 0.45, 1.0 / 1.099, 0.099 / 1.099, 1.0 / 4.5, 0.081}, 3,
+              {1.0f / 0.45f, 1.0f / 1.099f, 0.099f / 1.099f, 1.0f / 4.5f, 0.081}, 3,
               &tags));
           break;
         case JXL_TRANSFER_FUNCTION_LINEAR:
--- a/third_party/jpeg-xl/lib/jxl/splines.cc
+++ b/third_party/jpeg-xl/lib/jxl/splines.cc
@@ -48,14 +48,15 @@
   // sqrt(32). This is such that an input vector vector {x, 0, ..., 0} produces
   // a constant result of x. dct[0] was scaled in Dequantize() to allow uniform
   // treatment of all the coefficients.
+  constexpr float kPif = static_cast<float>(kPi);
   constexpr float kMultipliers[32] = {
-      kPi / 32 * 0,  kPi / 32 * 1,  kPi / 32 * 2,  kPi / 32 * 3,  kPi / 32 * 4,
-      kPi / 32 * 5,  kPi / 32 * 6,  kPi / 32 * 7,  kPi / 32 * 8,  kPi / 32 * 9,
-      kPi / 32 * 10, kPi / 32 * 11, kPi / 32 * 12, kPi / 32 * 13, kPi / 32 * 14,
-      kPi / 32 * 15, kPi / 32 * 16, kPi / 32 * 17, kPi / 32 * 18, kPi / 32 * 19,
-      kPi / 32 * 20, kPi / 32 * 21, kPi / 32 * 22, kPi / 32 * 23, kPi / 32 * 24,
-      kPi / 32 * 25, kPi / 32 * 26, kPi / 32 * 27, kPi / 32 * 28, kPi / 32 * 29,
-      kPi / 32 * 30, kPi / 32 * 31,
+      kPif / 32 * 0,  kPif / 32 * 1,  kPif / 32 * 2,  kPif / 32 * 3,  kPif / 32 * 4,
+      kPif / 32 * 5,  kPif / 32 * 6,  kPif / 32 * 7,  kPif / 32 * 8,  kPif / 32 * 9,
+      kPif / 32 * 10, kPif / 32 * 11, kPif / 32 * 12, kPif / 32 * 13, kPif / 32 * 14,
+      kPif / 32 * 15, kPif / 32 * 16, kPif / 32 * 17, kPif / 32 * 18, kPif / 32 * 19,
+      kPif / 32 * 20, kPif / 32 * 21, kPif / 32 * 22, kPif / 32 * 23, kPif / 32 * 24,
+      kPif / 32 * 25, kPif / 32 * 26, kPif / 32 * 27, kPif / 32 * 28, kPif / 32 * 29,
+      kPif / 32 * 30, kPif / 32 * 31,
   };
   HWY_CAPPED(float, 32) df;
   auto result = Zero(df);
