diff --git a/glib/glibmm/containerhandle_shared.h b/glib/glibmm/containerhandle_shared.h
index 21db808..d409ce5 100644
--- a/glib/glibmm/containerhandle_shared.h
+++ b/glib/glibmm/containerhandle_shared.h
@@ -117,10 +117,6 @@ struct TypeTraits
 
 #ifndef DOXYGEN_SHOULD_SKIP_THIS /* hide the specializations */
 
-// For some (probably, more spec-compliant) compilers, these specializations must
-// be next to the objects that they use.
-#ifdef GLIBMM_CAN_USE_DYNAMIC_CAST_IN_UNUSED_TEMPLATE_WITHOUT_DEFINITION
-
 /** Partial specialization for pointers to GtkObject instances.
  * @ingroup ContHelpers
  */
@@ -255,8 +251,6 @@ struct TypeTraits<Glib::RefPtr<const T>>
 
 #endif // GLIBMM_HAVE_DISAMBIGUOUS_CONST_TEMPLATE_SPECIALIZATIONS
 
-#endif // GLIBMM_CAN_USE_DYNAMIC_CAST_IN_UNUSED_TEMPLATE_WITHOUT_DEFINITION
-
 /** Specialization for UTF-8 strings.
  * @ingroup ContHelpers
  * When converting from C++ to C, Glib::ustring will be accepted as well as
diff --git a/glib/glibmm/containers.h b/glib/glibmm/containers.h
index 55fc2c5..260aae6 100644
--- a/glib/glibmm/containers.h
+++ b/glib/glibmm/containers.h
@@ -201,13 +201,7 @@ public:
       // The specific Glib::wrap() overloads don't do anything special anyway.
       GObject* cobj = static_cast<GObject*>(node_->data);
 
-#ifdef GLIBMM_CAN_USE_DYNAMIC_CAST_IN_UNUSED_TEMPLATE_WITHOUT_DEFINITION
       return *dynamic_cast<pointer>(Glib::wrap_auto(cobj, false));
-#else
-      // We really do need to use dynamic_cast<>, so I expect problems if this code is used.
-      // murrayc.
-      return *static_cast<pointer>(Glib::wrap_auto(cobj, false));
-#endif
     }
     return *static_cast<pointer>(nullptr); // boom!
   }
diff --git a/glib/glibmm/object.h b/glib/glibmm/object.h
index 824c6b7..a15821d 100644
--- a/glib/glibmm/object.h
+++ b/glib/glibmm/object.h
@@ -157,134 +157,6 @@ private:
   // virtual void set_manage();
 };
 
-// For some (proably, more spec-compliant) compilers, these specializations must
-// be next to the objects that they use.
-#ifndef GLIBMM_CAN_USE_DYNAMIC_CAST_IN_UNUSED_TEMPLATE_WITHOUT_DEFINITION
-#ifndef DOXYGEN_SHOULD_SKIP_THIS /* hide the specializations */
-
-namespace Container_Helpers
-{
-
-/** Partial specialization for pointers to GObject instances.
- * @ingroup ContHelpers
- * The C++ type is always a Glib::RefPtr<>.
- */
-template <class T>
-struct TypeTraits<Glib::RefPtr<T>>
-{
-  using CppType = Glib::RefPtr<T>;
-  using CType = typename T::BaseObjectType*;
-  using CTypeNonConst = typename T::BaseObjectType*;
-
-  static CType to_c_type(const CppType& ptr) { return Glib::unwrap(ptr); }
-  static CType to_c_type(CType ptr) { return ptr; }
-  static CppType to_cpp_type(CType ptr)
-  {
-    // return Glib::wrap(ptr, true);
-
-    // We copy/paste the wrap() implementation here,
-    // because we can not use a specific Glib::wrap(CType) overload here,
-    // because that would be "dependent", and g++ 3.4 does not allow that.
-    // The specific Glib::wrap() overloads don't do anything special anyway.
-    GObject* cobj = (GObject*)const_cast<CTypeNonConst>(ptr);
-    return Glib::RefPtr<T>(dynamic_cast<T*>(Glib::wrap_auto(cobj, true /* take_copy */)));
-    // We use dynamic_cast<> in case of multiple inheritance.
-  }
-
-  static void release_c_type(CType ptr)
-  {
-    GLIBMM_DEBUG_UNREFERENCE(nullptr, ptr);
-    g_object_unref(ptr);
-  }
-};
-
-// This confuses the SUN Forte compiler, so we ifdef it out:
-#ifdef GLIBMM_HAVE_DISAMBIGUOUS_CONST_TEMPLATE_SPECIALIZATIONS
-
-/** Partial specialization for pointers to const GObject instances.
- * @ingroup ContHelpers
- * The C++ type is always a Glib::RefPtr<>.
- */
-template <class T>
-struct TypeTraits<Glib::RefPtr<const T>>
-{
-  using CppType = Glib::RefPtr<const T>;
-  using CType = const typename T::BaseObjectType*;
-  using CTypeNonConst = typename T::BaseObjectType*;
-
-  static CType to_c_type(const CppType& ptr) { return Glib::unwrap(ptr); }
-  static CType to_c_type(CType ptr) { return ptr; }
-  static CppType to_cpp_type(CType ptr)
-  {
-    // return Glib::wrap(ptr, true);
-
-    // We copy/paste the wrap() implementation here,
-    // because we can not use a specific Glib::wrap(CType) overload here,
-    // because that would be "dependent", and g++ 3.4 does not allow that.
-    // The specific Glib::wrap() overloads don't do anything special anyway.
-    GObject* cobj = (GObject*)(ptr);
-    return Glib::RefPtr<const T>(
-      dynamic_cast<const T*>(Glib::wrap_auto(cobj, true /* take_copy */)));
-    // We use dynamic_cast<> in case of multiple inheritance.
-  }
-
-  static void release_c_type(CType ptr)
-  {
-    GLIBMM_DEBUG_UNREFERENCE(nullptr, ptr);
-    g_object_unref(const_cast<CTypeNonConst>(ptr));
-  }
-};
-
-#endif /* GLIBMM_HAVE_DISAMBIGUOUS_CONST_TEMPLATE_SPECIALIZATIONS */
-
-} // namespace Container_Helpers
-
-template <class T, class PtrT>
-inline PtrT
-Value_Pointer<T, PtrT>::get_(Glib::Object*) const
-{
-  return dynamic_cast<T*>(get_object());
-}
-
-/** Partial specialization for RefPtr<> to Glib::Object.
- * @ingroup glibmmValue
- */
-template <class T>
-class Value<Glib::RefPtr<T>> : public ValueBase_Object
-{
-public:
-  using CppType = Glib::RefPtr<T>;
-  using CType = typename T::BaseObjectType*;
-
-  static GType value_type() { return T::get_base_type(); }
-
-  void set(const CppType& data) { set_object(data.operator->()); }
-  CppType get() const { return Glib::RefPtr<T>::cast_dynamic(get_object_copy()); }
-};
-
-// The SUN Forte Compiler has a problem with this:
-#ifdef GLIBMM_HAVE_DISAMBIGUOUS_CONST_TEMPLATE_SPECIALIZATIONS
-
-/** Partial specialization for RefPtr<> to const Glib::Object.
- * @ingroup glibmmValue
- */
-template <class T>
-class Value<Glib::RefPtr<const T>> : public ValueBase_Object
-{
-public:
-  using CppType = Glib::RefPtr<const T>;
-  using CType = typename T::BaseObjectType*;
-
-  static GType value_type() { return T::get_base_type(); }
-
-  void set(const CppType& data) { set_object(const_cast<T*>(data.operator->())); }
-  CppType get() const { return Glib::RefPtr<T>::cast_dynamic(get_object_copy()); }
-};
-#endif /* GLIBMM_HAVE_DISAMBIGUOUS_CONST_TEMPLATE_SPECIALIZATIONS */
-
-#endif /* DOXYGEN_SHOULD_SKIP_THIS */
-#endif /* GLIBMM_CAN_USE_DYNAMIC_CAST_IN_UNUSED_TEMPLATE_WITHOUT_DEFINITION */
-
 } // namespace Glib
 
 #endif /* _GLIBMM_OBJECT_H */
diff --git a/glib/glibmm/value.h b/glib/glibmm/value.h
index f236471..95a7576 100644
--- a/glib/glibmm/value.h
+++ b/glib/glibmm/value.h
@@ -264,9 +264,6 @@ public:
   // CppType get() const { return Glib::wrap(static_cast<typename T::BaseObjectType*>(get_boxed()), true); }
 };
 
-// More spec-compliant compilers (such as Tru64) need this to be near Glib::Object instead.
-#ifdef GLIBMM_CAN_USE_DYNAMIC_CAST_IN_UNUSED_TEMPLATE_WITHOUT_DEFINITION
-
 /** Partial specialization for RefPtr<> to Glib::Object.
  * @ingroup glibmmValue
  */
@@ -303,8 +300,6 @@ public:
 };
 #endif // GLIBMM_HAVE_DISAMBIGUOUS_CONST_TEMPLATE_SPECIALIZATIONS
 
-#endif // GLIBMM_CAN_USE_DYNAMIC_CAST_IN_UNUSED_TEMPLATE_WITHOUT_DEFINITION
-
 } // namespace Glib
 
 /* Include generated specializations of Glib::Value<> for fundamental types:
diff --git a/glib/glibmm/value_custom.h b/glib/glibmm/value_custom.h
index 53da3db..de35925 100644
--- a/glib/glibmm/value_custom.h
+++ b/glib/glibmm/value_custom.h
@@ -159,15 +159,12 @@ Value_Pointer<T, PtrT>::set_(PtrT data, Glib::Object*)
   set_object(const_cast<T*>(data));
 }
 
-// More spec-compliant compilers (such as Tru64) need this to be near Glib::Object instead.
-#ifdef GLIBMM_CAN_USE_DYNAMIC_CAST_IN_UNUSED_TEMPLATE_WITHOUT_DEFINITION
 template <class T, class PtrT>
 inline PtrT
 Value_Pointer<T, PtrT>::get_(Glib::Object*) const
 {
   return dynamic_cast<T*>(get_object());
 }
-#endif // GLIBMM_CAN_USE_DYNAMIC_CAST_IN_UNUSED_TEMPLATE_WITHOUT_DEFINITION
 
 /** Implementation for custom pointers **/
 
